"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5846],{21567:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>a,frontMatter:()=>d,metadata:()=>o,toc:()=>c});var n=t(74848),s=t(28453);const d={title:"Design",sidebar_position:3},r=void 0,o={id:"ESP32-Wifi-Tool/Design",title:"Design",description:"High-Level Design",source:"@site/Projects/ESP32-Wifi-Tool/Design.md",sourceDirName:"ESP32-Wifi-Tool",slug:"/ESP32-Wifi-Tool/Design",permalink:"/Projects/ESP32-Wifi-Tool/Design",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Design",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Specifications",permalink:"/Projects/ESP32-Wifi-Tool/Specifications"},next:{title:"The Assembled Prototype",permalink:"/Projects/ESP32-Wifi-Tool/Prototyping"}},l={},c=[{value:"High-Level Design",id:"high-level-design",level:3},{value:"Functional Block Diagram",id:"functional-block-diagram",level:4},{value:"Detailed Design",id:"detailed-design",level:3},{value:"ESP32S - NodeMCU Edition",id:"esp32s---nodemcu-edition",level:4},{value:"The TFT LCD Wiring",id:"the-tft-lcd-wiring",level:3},{value:"Button Wiring",id:"button-wiring",level:3}];function h(e){const i={h3:"h3",h4:"h4",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h3,{id:"high-level-design",children:"High-Level Design"}),"\n",(0,n.jsx)(i.p,{children:"The design of Wifi Tool emphasizes modularity with iterative feature-rollouts. Data is\ncollected via the antenna, processed by the ESP32 MCU, and displayed by the LCD. Control\nmechanisms such as interrupts and UI scrolling are implemented by pushbuttons switches\nrespectively. The below functional diagram outlines the process-flow of the system."}),"\n",(0,n.jsx)(i.h4,{id:"functional-block-diagram",children:"Functional Block Diagram"}),"\n",(0,n.jsx)(i.p,{children:"It is advised for the readers to think about how to design the software augmentations in\naddition to the existing code base, and the above block diagram is a good entry point for\nthinking about the modularity of the design in an abstract view."}),"\n",(0,n.jsx)("img",{src:"/img/docs/projects/esp32-wifi-tool/functional-blocks.png",width:"600"}),"\n",(0,n.jsx)(i.h3,{id:"detailed-design",children:"Detailed Design"}),"\n",(0,n.jsx)(i.h4,{id:"esp32s---nodemcu-edition",children:"ESP32S - NodeMCU Edition"}),"\n",(0,n.jsx)(i.p,{children:"We need to be careful of working with ESP modules due to a variety of versions which may\ncause wiring confusion. The specific model to this project is the NodeMCU version, and the\npin layout is illustrated below."}),"\n",(0,n.jsx)(i.p,{children:"Note it supports both 3.3V and 5V input voltages."}),"\n",(0,n.jsx)("img",{src:"/img/docs/projects/esp32-wifi-tool/pinout.png",width:"600"}),"\n",(0,n.jsx)(i.h3,{id:"the-tft-lcd-wiring",children:"The TFT LCD Wiring"}),"\n",(0,n.jsx)(i.p,{children:"Due to manufacturing variability, one may expect the LCD module to be different in terms\nof the pin-outs. The below table shows the connection established between the LCD and\nthe ESP32 MCU."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"LCD Pin"}),(0,n.jsx)(i.th,{children:"Description"}),(0,n.jsx)(i.th,{children:"To ESP Pin"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"1 \u2013 RST"}),(0,n.jsx)(i.td,{children:"Reset"}),(0,n.jsx)(i.td,{children:"GPIO 27"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"2 \u2013 CS"}),(0,n.jsx)(i.td,{children:"Chip Select"}),(0,n.jsx)(i.td,{children:"GPIO 5"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"3 \u2013 D/C"}),(0,n.jsx)(i.td,{children:"Data/Cmd"}),(0,n.jsx)(i.td,{children:"GPIO 32"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"4 \u2013 DIN"}),(0,n.jsx)(i.td,{children:"MOSI Slave"}),(0,n.jsx)(i.td,{children:"GPIO 23"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"5 \u2013 CLK"}),(0,n.jsx)(i.td,{children:"Clock"}),(0,n.jsx)(i.td,{children:"GPIO 18"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"6 \u2013 VCC"}),(0,n.jsx)(i.td,{children:"Power"}),(0,n.jsx)(i.td,{children:"5V"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"7 \u2013 BL"}),(0,n.jsx)(i.td,{children:"Backlight"}),(0,n.jsx)(i.td,{children:"5V"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"8 \u2013 GND"}),(0,n.jsx)(i.td,{children:"0V"}),(0,n.jsx)(i.td,{children:"GND"})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"button-wiring",children:"Button Wiring"}),"\n",(0,n.jsx)(i.p,{children:"There are a total of 5 push-buttons used for the user interface. Each button is wired with a\npull-up resistor at 10k Ohms from the Vcc. The wiring diagram is shown below, and a 3.3uF\ncapacitor is connected in parallel with the resistor for debounce purposes."}),"\n",(0,n.jsx)("img",{src:"/img/docs/projects/esp32-wifi-tool/button-wiring.png",width:"300"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"PB"}),(0,n.jsx)(i.th,{children:"Description"}),(0,n.jsx)(i.th,{children:"To ESP Pin"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"Function"}),(0,n.jsx)(i.td,{children:"GPIO 15"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"2"}),(0,n.jsx)(i.td,{children:"Go Back"}),(0,n.jsx)(i.td,{children:"GPIO 16"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"3"}),(0,n.jsx)(i.td,{children:"Cursor Up"}),(0,n.jsx)(i.td,{children:"GPIO 17"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"4"}),(0,n.jsx)(i.td,{children:"Cursor Down"}),(0,n.jsx)(i.td,{children:"GPIO 21"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"5"}),(0,n.jsx)(i.td,{children:"Enter"}),(0,n.jsx)(i.td,{children:"GPIO 22"})]})]})]})]})}function a(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},28453:(e,i,t)=>{t.d(i,{R:()=>r,x:()=>o});var n=t(96540);const s={},d=n.createContext(s);function r(e){const i=n.useContext(d);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(d.Provider,{value:i},e.children)}}}]);