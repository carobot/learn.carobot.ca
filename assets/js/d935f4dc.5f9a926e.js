"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4211],{75178:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var r=n(74848),s=n(28453);const i={title:"Project 5.2: One-way Data Communication - LED Control",sidebar_position:8},o=void 0,a={id:"ESP32-Starter-Kit/Project-5.2",title:"Project 5.2: One-way Data Communication - LED Control",description:"Overview:",source:"@site/Projects/ESP32-Starter-Kit/Project-5.2.md",sourceDirName:"ESP32-Starter-Kit",slug:"/ESP32-Starter-Kit/Project-5.2",permalink:"/Projects/ESP32-Starter-Kit/Project-5.2",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"Project 5.2: One-way Data Communication - LED Control",sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Project 5.1: One-way Data Communication - Message Display",permalink:"/Projects/ESP32-Starter-Kit/Project-5.1"},next:{title:"Project 6.1: Two-way Data Communication - String Gauge to PC",permalink:"/Projects/ESP32-Starter-Kit/Project-6.1"}},c={},d=[{value:"Overview:",id:"overview",level:2},{value:"Materials:",id:"materials",level:2},{value:"Objectives:",id:"objectives",level:2},{value:"Hardware Assembly:",id:"hardware-assembly",level:2},{value:"Pin Connection:",id:"pin-connection",level:2},{value:"Network Diagram",id:"network-diagram",level:2},{value:"Pseudocode:",id:"pseudocode",level:2},{value:"ESP32",id:"esp32",level:4},{value:"Instructions:",id:"instructions",level:2},{value:"What you should see:",id:"what-you-should-see",level:4}];function l(e){const t={a:"a",code:"code",h2:"h2",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"overview",children:"Overview:"}),"\n",(0,r.jsx)(t.p,{children:"Project 5.2 is about setting up a firmware utilizing the ESP32\u2019s capabilities for wireless communication. This project will guide you how to control RGB LEDs via UDP communications. The firmware is designed to respond to remote commands that adjust LED colors based on received inputs, providing an immediate visual presentation of the data on the TFT display. Previously, we set up a client on the computer, you can reuse the same client.cpp but you can also use Package Sender as a client."}),"\n",(0,r.jsx)(t.h2,{id:"materials",children:"Materials:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Component"}),(0,r.jsx)(t.th,{children:"Image"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.a,{href:"https://www.canadarobotix.com/products/3056",children:'1.8" TFT LCD Screen'})}),(0,r.jsx)(t.td,{children:(0,r.jsx)("img",{src:"/img/docs/projects/esp32-starter-kit/LCD-Screen.webp",width:"200"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.a,{href:"https://www.canadarobotix.com/products/5138",children:"330 \u03a9 Resistors"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)("img",{src:"/img/docs/projects/esp32-starter-kit/resistors.webp",width:"200"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.a,{href:"https://www.canadarobotix.com/products/546",children:"RGB LED"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)("img",{src:"/img/docs/projects/esp32-starter-kit/RGB-LED.png",width:"200"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.a,{href:"https://www.canadarobotix.com/products/2594",children:"ESP32 Dev Board"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)("img",{src:"/img/docs/projects/esp32-starter-kit/ESP32.webp",width:"200"})})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"objectives",children:"Objectives:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Establish UDP communication: Implement a UDP server on the ESP32 that can receive color control commands from a remote client"}),"\n",(0,r.jsx)(t.li,{children:"Enhance Visual Interaction: Utilize an ST7735 TFT display to provide feedback on the received commands and display the message on the screen"}),"\n",(0,r.jsx)(t.li,{children:"Dynamic LED Control: Develop a system where RGB LEDs change color based on the commands received via the UDP network."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"hardware-assembly",children:"Hardware Assembly:"}),"\n",(0,r.jsx)("img",{src:"/img/docs/projects/esp32-starter-kit/hardware-assembly-4.png",width:"700"}),"\n",(0,r.jsx)(t.h2,{id:"pin-connection",children:"Pin Connection:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Color"}),(0,r.jsx)(t.th,{children:"To ESP32 Pin"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"RED"}),(0,r.jsx)(t.td,{children:"P22"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"GND"}),(0,r.jsx)(t.td,{children:"GND"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"GREEN"}),(0,r.jsx)(t.td,{children:"P21"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"BLUE"}),(0,r.jsx)(t.td,{children:"P19"})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"network-diagram",children:"Network Diagram"}),"\n",(0,r.jsx)("img",{src:"/img/docs/projects/esp32-starter-kit/ESP32-12.png",width:"700"}),"\n",(0,r.jsx)(t.h2,{id:"pseudocode",children:"Pseudocode:"}),"\n",(0,r.jsx)(t.h4,{id:"esp32",children:"ESP32"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Declare necessary libraries and define pins\r\nInitialize TFT display settings\r\nInitialize WiFi as Access Point\r\nPrint IP Address and UDP port on TFT display\r\nSet up UDP communication\r\nConfigure LED pins and perform initial LED blinking sequence\r\nIn the main loop:\r\n    Check for incoming UDP packets\r\n    If a packet is received:\r\n        Read and display the packet content on the TFT display\r\n        Convert the received string to an integer and set the LED color\r\n\r\nDefine setColor function:\r\n    Calculate color intensities based on the input value\r\n    Set the LED to the calculated color intensities\r\n    Wait for 5 seconds before the next change\n"})}),"\n",(0,r.jsx)(t.h2,{id:"instructions",children:"Instructions:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["Download and install ",(0,r.jsx)(t.a,{href:"https://packetsender.com/download",children:"Package Sender"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["Visit this ",(0,r.jsx)(t.a,{href:"https://github.com/matoanbach/Starter-Kit/tree/main/Project5/Project5.2/project5_2",children:"repository"})," and download project5_2.ino"]}),"\n",(0,r.jsx)(t.li,{children:"In project5_2.ino, you can change the name and password of the access point. Afterward,\r\nupload the code into the ESP32. If you don\u2019t have a battery for the ESP32, then you can use\r\nyour computer as a power souce for the ESP32."}),"\n",(0,r.jsx)(t.li,{children:"The IP address of the ESP32 should be there on the TFT screen, so note it down because this\r\nwill be used as an address that your message will be sent to."}),"\n",(0,r.jsx)(t.li,{children:"Open Package Sender and connect your computer with the name of your access point or\r\n\u201cESP32-Access-point\u201d as default. In Package Sender, you need to write an integer value under\r\nASCII section, you copy the address and the port displayed on TFT screen and then put them\r\nunder address and port section. Because we set up the ESP32 to accept UDP packet, we\r\nshould set it to UDP in PackageSender and then press send. To be more illustrative, an picture\r\nis provided below:"}),"\n"]}),"\n",(0,r.jsx)("img",{src:"/img/docs/projects/esp32-starter-kit/ESP32-13.png",width:"500"}),"\n",(0,r.jsx)(t.h4,{id:"what-you-should-see",children:"What you should see:"}),"\n",(0,r.jsx)("img",{src:"/img/docs/projects/esp32-starter-kit/ESP32-14.png",width:"400"})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(96540);const s={},i=r.createContext(s);function o(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);